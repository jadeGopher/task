// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for AnalyticsSection.
const (
	CLIENTS  AnalyticsSection = "CLIENTS"
	SESSIONS AnalyticsSection = "SESSIONS"
)

// Defines values for FilterKey.
const (
	ANSWERTEXT             FilterKey = "ANSWER_TEXT"
	BOTID                  FilterKey = "BOT_ID"
	CALLTASKID             FilterKey = "CALL_TASK_ID"
	CHANNELTYPE            FilterKey = "CHANNEL_TYPE"
	CLIENTIDORNAME         FilterKey = "CLIENT_ID_OR_NAME"
	CLIENTJOINTIME         FilterKey = "CLIENT_JOIN_TIME"
	CLIENTLASTACTIVITYTIME FilterKey = "CLIENT_LAST_ACTIVITY_TIME"
	COMMENTTEXT            FilterKey = "COMMENT_TEXT"
	CUSTOMFIELDSINRESPONSE FilterKey = "CUSTOM_FIELDS_IN_RESPONSE"
	EXCEPTIONEXISTENCE     FilterKey = "EXCEPTION_EXISTENCE"
	INITIATOR              FilterKey = "INITIATOR"
	INTENT                 FilterKey = "INTENT"
	LOGLABELS              FilterKey = "LOG_LABELS"
	MESSAGECOUNT           FilterKey = "MESSAGE_COUNT"
	MESSAGETEXT            FilterKey = "MESSAGE_TEXT"
	MESSAGETIME            FilterKey = "MESSAGE_TIME"
	MESSAGETYPE            FilterKey = "MESSAGE_TYPE"
	NLPCLASS               FilterKey = "NLP_CLASS"
	NLPSTATE               FilterKey = "NLP_STATE"
	SESSIONDATA            FilterKey = "SESSION_DATA"
	SESSIONENDTIME         FilterKey = "SESSION_END_TIME"
	SESSIONID              FilterKey = "SESSION_ID"
	SESSIONLABELS          FilterKey = "SESSION_LABELS"
	SESSIONRESULT          FilterKey = "SESSION_RESULT"
	SESSIONSTARTTIME       FilterKey = "SESSION_START_TIME"
	STATEROUTES            FilterKey = "STATE_ROUTES"
	TRANSFERTOOPERATOR     FilterKey = "TRANSFER_TO_OPERATOR"
	WITHOUTEMPTYMESSAGES   FilterKey = "WITHOUT_EMPTY_MESSAGES"
	WITHOUTEMPTYSESSIONS   FilterKey = "WITHOUT_EMPTY_SESSIONS"
)

// Defines values for IntervalType.
const (
	DAY     IntervalType = "DAY"
	HOUR    IntervalType = "HOUR"
	MONTH   IntervalType = "MONTH"
	QUARTER IntervalType = "QUARTER"
	WEEK    IntervalType = "WEEK"
	YEAR    IntervalType = "YEAR"
)

// AnalyticsFilter defines model for AnalyticsFilter.
type AnalyticsFilter struct {
	// From Format yyyy-MM-ddTHH:mm:ss.SSSZ
	From *time.Time `json:"from,omitempty"`
	Key  FilterKey  `json:"key"`

	// To Format yyyy-MM-ddTHH:mm:ss.SSSZ
	To   *time.Time `json:"to,omitempty"`
	Type string     `json:"type"`
}

// AnalyticsSection defines model for AnalyticsSection.
type AnalyticsSection string

// ClientInfo defines model for ClientInfo.
type ClientInfo struct {
	FirstName *string `json:"firstName,omitempty"`
	Id        string  `json:"id"`
	LastName  *string `json:"lastName,omitempty"`
	Username  *string `json:"username,omitempty"`
}

// FilterKey defines model for FilterKey.
type FilterKey string

// FilterOption defines model for FilterOption.
type FilterOption struct {
	ChildValues *[]string `json:"childValues,omitempty"`
	Frequency   *int64    `json:"frequency,omitempty"`
	IsSelected  bool      `json:"isSelected"`
	Label       string    `json:"label"`
	ParentValue *string   `json:"parentValue,omitempty"`
	Value       string    `json:"value"`
}

// FiltersDto defines model for FiltersDto.
type FiltersDto struct {
	Filters *[]AnalyticsFilter `json:"filters,omitempty"`
}

// IntervalFilterOptions defines model for IntervalFilterOptions.
type IntervalFilterOptions struct {
	MaxValue float64 `json:"maxValue"`
	MinValue float64 `json:"minValue"`
}

// IntervalType defines model for IntervalType.
type IntervalType string

// ObjectNode defines model for ObjectNode.
type ObjectNode = map[string]interface{}

// Pagination defines model for Pagination.
type Pagination struct {
	PageNum    int32 `json:"pageNum"`
	PageSize   int32 `json:"pageSize"`
	TotalCount int64 `json:"totalCount"`
}

// ProjectsSessionsCountDto defines model for ProjectsSessionsCountDto.
type ProjectsSessionsCountDto struct {
	Amount           int64  `json:"amount"`
	ProjectShortName string `json:"projectShortName"`
}

// SessionInfo defines model for SessionInfo.
type SessionInfo struct {
	AudioFileUrl     *string            `json:"audioFileUrl,omitempty"`
	BotId            string             `json:"botId"`
	CallTaskId       *int64             `json:"callTaskId,omitempty"`
	ChannelType      string             `json:"channelType"`
	Client           ClientInfo         `json:"client"`
	CustomFields     *ObjectNode        `json:"customFields,omitempty"`
	Duration         *int64             `json:"duration,omitempty"`
	FirstQuestion    *string            `json:"firstQuestion,omitempty"`
	IsCallIncoming   *bool              `json:"isCallIncoming,omitempty"`
	IsLivechat       bool               `json:"isLivechat"`
	Labels           *[]SessionLabelDto `json:"labels,omitempty"`
	LastQuestion     *string            `json:"lastQuestion,omitempty"`
	ProjectShortName string             `json:"projectShortName"`
	QuestionCount    *int64             `json:"questionCount,omitempty"`
	ResponseData     *ObjectNode        `json:"responseData,omitempty"`
	SessionData      *map[string]string `json:"sessionData,omitempty"`
	SessionId        string             `json:"sessionId"`
	SessionResult    *string            `json:"sessionResult,omitempty"`

	// StartTime Format yyyy-MM-ddTHH:mm:ss.SSSZ
	StartTime time.Time `json:"startTime"`
}

// SessionLabelDto defines model for SessionLabelDto.
type SessionLabelDto struct {
	Id       int64  `json:"id"`
	Name     string `json:"name"`
	Priority int32  `json:"priority"`
}

// SessionsData defines model for SessionsData.
type SessionsData struct {
	FilterSetId *string       `json:"filterSetId,omitempty"`
	Paging      Pagination    `json:"paging"`
	Sessions    []SessionInfo `json:"sessions"`
}

// UserFilterSetDto defines model for UserFilterSetDto.
type UserFilterSetDto struct {
	FilterSetId  string             `json:"filterSetId"`
	Filters      *[]AnalyticsFilter `json:"filters,omitempty"`
	IntervalType *IntervalType      `json:"intervalType,omitempty"`
	Step         *int32             `json:"step,omitempty"`
}

// AnalyticsSectionParamRequired defines model for analyticsSectionParamRequired.
type AnalyticsSectionParamRequired = AnalyticsSection

// AnalyticsToken defines model for analyticsToken.
type AnalyticsToken = string

// FilterKeyParamRequired defines model for filterKeyParamRequired.
type FilterKeyParamRequired = FilterKey

// FilterSetId defines model for filterSetId.
type FilterSetId = string

// LanguageHeader defines model for languageHeader.
type LanguageHeader = string

// NeedToReturnSessionLabelsParamOptional defines model for needToReturnSessionLabelsParamOptional.
type NeedToReturnSessionLabelsParamOptional = bool

// PageParamOptional defines model for pageParamOptional.
type PageParamOptional = int32

// SizeParamOptional defines model for sizeParamOptional.
type SizeParamOptional = int32

// GetFilterOptionsParams defines parameters for GetFilterOptions.
type GetFilterOptionsParams struct {
	// FilterKey filterkey
	FilterKey FilterKeyParamRequired `form:"filterKey" json:"filterKey"`

	// AnalyticsSection analytics section
	AnalyticsSection AnalyticsSectionParamRequired `form:"analyticsSection" json:"analyticsSection"`

	// Page Page number
	Page *PageParamOptional `form:"page,omitempty" json:"page,omitempty"`

	// Size Page size
	Size *SizeParamOptional `form:"size,omitempty" json:"size,omitempty"`

	// Language Language of resources
	Language *LanguageHeader `json:"language,omitempty"`
}

// GetIntervalFilterOptionsParams defines parameters for GetIntervalFilterOptions.
type GetIntervalFilterOptionsParams struct {
	// FilterKey filterkey
	FilterKey FilterKeyParamRequired `form:"filterKey" json:"filterKey"`

	// AnalyticsSection analytics section
	AnalyticsSection AnalyticsSectionParamRequired `form:"analyticsSection" json:"analyticsSection"`

	// Language Language of resources
	Language *LanguageHeader `json:"language,omitempty"`
}

// GetSessionDataByFilterParams defines parameters for GetSessionDataByFilter.
type GetSessionDataByFilterParams struct {
	// Page Page number
	Page *PageParamOptional `form:"page,omitempty" json:"page,omitempty"`

	// Size Page size
	Size *SizeParamOptional `form:"size,omitempty" json:"size,omitempty"`

	// NeedToReturnSessionLabels Need to return session labels parameter
	NeedToReturnSessionLabels *NeedToReturnSessionLabelsParamOptional `form:"needToReturnSessionLabels,omitempty" json:"needToReturnSessionLabels,omitempty"`
}

// GetFilterOptionsJSONRequestBody defines body for GetFilterOptions for application/json ContentType.
type GetFilterOptionsJSONRequestBody = FiltersDto

// GetIntervalFilterOptionsJSONRequestBody defines body for GetIntervalFilterOptions for application/json ContentType.
type GetIntervalFilterOptionsJSONRequestBody = FiltersDto

// GetSessionDataByFilterJSONRequestBody defines body for GetSessionDataByFilter for application/json ContentType.
type GetSessionDataByFilterJSONRequestBody = FiltersDto

// CreateFilterSetIdJSONRequestBody defines body for CreateFilterSetId for application/json ContentType.
type CreateFilterSetIdJSONRequestBody = FiltersDto

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetFilterOptionsWithBody request with any body
	GetFilterOptionsWithBody(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetFilterOptions(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, body GetFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntervalFilterOptionsWithBody request with any body
	GetIntervalFilterOptionsWithBody(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetIntervalFilterOptions(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, body GetIntervalFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CountAllProjectsSessions request
	CountAllProjectsSessions(ctx context.Context, token AnalyticsToken, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSessionDataByFilterWithBody request with any body
	GetSessionDataByFilterWithBody(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSessionDataByFilter(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, body GetSessionDataByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterSetIdWithBody request with any body
	CreateFilterSetIdWithBody(ctx context.Context, token AnalyticsToken, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterSetId(ctx context.Context, token AnalyticsToken, body CreateFilterSetIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFilterSet request
	GetUserFilterSet(ctx context.Context, token AnalyticsToken, filterSetId FilterSetId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetFilterOptionsWithBody(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterOptionsRequestWithBody(c.Server, token, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterOptions(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, body GetFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterOptionsRequest(c.Server, token, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntervalFilterOptionsWithBody(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntervalFilterOptionsRequestWithBody(c.Server, token, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntervalFilterOptions(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, body GetIntervalFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntervalFilterOptionsRequest(c.Server, token, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CountAllProjectsSessions(ctx context.Context, token AnalyticsToken, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCountAllProjectsSessionsRequest(c.Server, token)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionDataByFilterWithBody(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionDataByFilterRequestWithBody(c.Server, token, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSessionDataByFilter(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, body GetSessionDataByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSessionDataByFilterRequest(c.Server, token, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterSetIdWithBody(ctx context.Context, token AnalyticsToken, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterSetIdRequestWithBody(c.Server, token, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterSetId(ctx context.Context, token AnalyticsToken, body CreateFilterSetIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterSetIdRequest(c.Server, token, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFilterSet(ctx context.Context, token AnalyticsToken, filterSetId FilterSetId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFilterSetRequest(c.Server, token, filterSetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetFilterOptionsRequest calls the generic GetFilterOptions builder with application/json body
func NewGetFilterOptionsRequest(server string, token AnalyticsToken, params *GetFilterOptionsParams, body GetFilterOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetFilterOptionsRequestWithBody(server, token, params, "application/json", bodyReader)
}

// NewGetFilterOptionsRequestWithBody generates requests for GetFilterOptions with any type of body
func NewGetFilterOptionsRequestWithBody(server string, token AnalyticsToken, params *GetFilterOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/filter-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterKey", runtime.ParamLocationQuery, params.FilterKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analyticsSection", runtime.ParamLocationQuery, params.AnalyticsSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Language != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationHeader, *params.Language)
			if err != nil {
				return nil, err
			}

			req.Header.Set("language", headerParam0)
		}

	}

	return req, nil
}

// NewGetIntervalFilterOptionsRequest calls the generic GetIntervalFilterOptions builder with application/json body
func NewGetIntervalFilterOptionsRequest(server string, token AnalyticsToken, params *GetIntervalFilterOptionsParams, body GetIntervalFilterOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetIntervalFilterOptionsRequestWithBody(server, token, params, "application/json", bodyReader)
}

// NewGetIntervalFilterOptionsRequestWithBody generates requests for GetIntervalFilterOptions with any type of body
func NewGetIntervalFilterOptionsRequestWithBody(server string, token AnalyticsToken, params *GetIntervalFilterOptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/interval-filter-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filterKey", runtime.ParamLocationQuery, params.FilterKey); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analyticsSection", runtime.ParamLocationQuery, params.AnalyticsSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.Language != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "language", runtime.ParamLocationHeader, *params.Language)
			if err != nil {
				return nil, err
			}

			req.Header.Set("language", headerParam0)
		}

	}

	return req, nil
}

// NewCountAllProjectsSessionsRequest generates requests for CountAllProjectsSessions
func NewCountAllProjectsSessionsRequest(server string, token AnalyticsToken) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/projects/sessions/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSessionDataByFilterRequest calls the generic GetSessionDataByFilter builder with application/json body
func NewGetSessionDataByFilterRequest(server string, token AnalyticsToken, params *GetSessionDataByFilterParams, body GetSessionDataByFilterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSessionDataByFilterRequestWithBody(server, token, params, "application/json", bodyReader)
}

// NewGetSessionDataByFilterRequestWithBody generates requests for GetSessionDataByFilter with any type of body
func NewGetSessionDataByFilterRequestWithBody(server string, token AnalyticsToken, params *GetSessionDataByFilterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/sessions/filter", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NeedToReturnSessionLabels != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needToReturnSessionLabels", runtime.ParamLocationQuery, *params.NeedToReturnSessionLabels); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateFilterSetIdRequest calls the generic CreateFilterSetId builder with application/json body
func NewCreateFilterSetIdRequest(server string, token AnalyticsToken, body CreateFilterSetIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterSetIdRequestWithBody(server, token, "application/json", bodyReader)
}

// NewCreateFilterSetIdRequestWithBody generates requests for CreateFilterSetId with any type of body
func NewCreateFilterSetIdRequestWithBody(server string, token AnalyticsToken, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/user-filter-sets/filterSetId", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserFilterSetRequest generates requests for GetUserFilterSet
func NewGetUserFilterSetRequest(server string, token AnalyticsToken, filterSetId FilterSetId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token", runtime.ParamLocationPath, token)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "filterSetId", runtime.ParamLocationPath, filterSetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/reporter/p/%s/user-filter-sets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetFilterOptionsWithBodyWithResponse request with any body
	GetFilterOptionsWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetFilterOptionsResponse, error)

	GetFilterOptionsWithResponse(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, body GetFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetFilterOptionsResponse, error)

	// GetIntervalFilterOptionsWithBodyWithResponse request with any body
	GetIntervalFilterOptionsWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetIntervalFilterOptionsResponse, error)

	GetIntervalFilterOptionsWithResponse(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, body GetIntervalFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetIntervalFilterOptionsResponse, error)

	// CountAllProjectsSessionsWithResponse request
	CountAllProjectsSessionsWithResponse(ctx context.Context, token AnalyticsToken, reqEditors ...RequestEditorFn) (*CountAllProjectsSessionsResponse, error)

	// GetSessionDataByFilterWithBodyWithResponse request with any body
	GetSessionDataByFilterWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSessionDataByFilterResponse, error)

	GetSessionDataByFilterWithResponse(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, body GetSessionDataByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSessionDataByFilterResponse, error)

	// CreateFilterSetIdWithBodyWithResponse request with any body
	CreateFilterSetIdWithBodyWithResponse(ctx context.Context, token AnalyticsToken, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterSetIdResponse, error)

	CreateFilterSetIdWithResponse(ctx context.Context, token AnalyticsToken, body CreateFilterSetIdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterSetIdResponse, error)

	// GetUserFilterSetWithResponse request
	GetUserFilterSetWithResponse(ctx context.Context, token AnalyticsToken, filterSetId FilterSetId, reqEditors ...RequestEditorFn) (*GetUserFilterSetResponse, error)
}

type GetFilterOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]FilterOption
}

// Status returns HTTPResponse.Status
func (r GetFilterOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntervalFilterOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntervalFilterOptions
}

// Status returns HTTPResponse.Status
func (r GetIntervalFilterOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntervalFilterOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CountAllProjectsSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProjectsSessionsCountDto
}

// Status returns HTTPResponse.Status
func (r CountAllProjectsSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CountAllProjectsSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSessionDataByFilterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionsData
}

// Status returns HTTPResponse.Status
func (r GetSessionDataByFilterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSessionDataByFilterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterSetIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r CreateFilterSetIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterSetIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFilterSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserFilterSetDto
}

// Status returns HTTPResponse.Status
func (r GetUserFilterSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFilterSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetFilterOptionsWithBodyWithResponse request with arbitrary body returning *GetFilterOptionsResponse
func (c *ClientWithResponses) GetFilterOptionsWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetFilterOptionsResponse, error) {
	rsp, err := c.GetFilterOptionsWithBody(ctx, token, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterOptionsResponse(rsp)
}

func (c *ClientWithResponses) GetFilterOptionsWithResponse(ctx context.Context, token AnalyticsToken, params *GetFilterOptionsParams, body GetFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetFilterOptionsResponse, error) {
	rsp, err := c.GetFilterOptions(ctx, token, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterOptionsResponse(rsp)
}

// GetIntervalFilterOptionsWithBodyWithResponse request with arbitrary body returning *GetIntervalFilterOptionsResponse
func (c *ClientWithResponses) GetIntervalFilterOptionsWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetIntervalFilterOptionsResponse, error) {
	rsp, err := c.GetIntervalFilterOptionsWithBody(ctx, token, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntervalFilterOptionsResponse(rsp)
}

func (c *ClientWithResponses) GetIntervalFilterOptionsWithResponse(ctx context.Context, token AnalyticsToken, params *GetIntervalFilterOptionsParams, body GetIntervalFilterOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*GetIntervalFilterOptionsResponse, error) {
	rsp, err := c.GetIntervalFilterOptions(ctx, token, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntervalFilterOptionsResponse(rsp)
}

// CountAllProjectsSessionsWithResponse request returning *CountAllProjectsSessionsResponse
func (c *ClientWithResponses) CountAllProjectsSessionsWithResponse(ctx context.Context, token AnalyticsToken, reqEditors ...RequestEditorFn) (*CountAllProjectsSessionsResponse, error) {
	rsp, err := c.CountAllProjectsSessions(ctx, token, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCountAllProjectsSessionsResponse(rsp)
}

// GetSessionDataByFilterWithBodyWithResponse request with arbitrary body returning *GetSessionDataByFilterResponse
func (c *ClientWithResponses) GetSessionDataByFilterWithBodyWithResponse(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSessionDataByFilterResponse, error) {
	rsp, err := c.GetSessionDataByFilterWithBody(ctx, token, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionDataByFilterResponse(rsp)
}

func (c *ClientWithResponses) GetSessionDataByFilterWithResponse(ctx context.Context, token AnalyticsToken, params *GetSessionDataByFilterParams, body GetSessionDataByFilterJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSessionDataByFilterResponse, error) {
	rsp, err := c.GetSessionDataByFilter(ctx, token, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSessionDataByFilterResponse(rsp)
}

// CreateFilterSetIdWithBodyWithResponse request with arbitrary body returning *CreateFilterSetIdResponse
func (c *ClientWithResponses) CreateFilterSetIdWithBodyWithResponse(ctx context.Context, token AnalyticsToken, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterSetIdResponse, error) {
	rsp, err := c.CreateFilterSetIdWithBody(ctx, token, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterSetIdResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterSetIdWithResponse(ctx context.Context, token AnalyticsToken, body CreateFilterSetIdJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterSetIdResponse, error) {
	rsp, err := c.CreateFilterSetId(ctx, token, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterSetIdResponse(rsp)
}

// GetUserFilterSetWithResponse request returning *GetUserFilterSetResponse
func (c *ClientWithResponses) GetUserFilterSetWithResponse(ctx context.Context, token AnalyticsToken, filterSetId FilterSetId, reqEditors ...RequestEditorFn) (*GetUserFilterSetResponse, error) {
	rsp, err := c.GetUserFilterSet(ctx, token, filterSetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFilterSetResponse(rsp)
}

// ParseGetFilterOptionsResponse parses an HTTP response from a GetFilterOptionsWithResponse call
func ParseGetFilterOptionsResponse(rsp *http.Response) (*GetFilterOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []FilterOption
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetIntervalFilterOptionsResponse parses an HTTP response from a GetIntervalFilterOptionsWithResponse call
func ParseGetIntervalFilterOptionsResponse(rsp *http.Response) (*GetIntervalFilterOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntervalFilterOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntervalFilterOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCountAllProjectsSessionsResponse parses an HTTP response from a CountAllProjectsSessionsWithResponse call
func ParseCountAllProjectsSessionsResponse(rsp *http.Response) (*CountAllProjectsSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CountAllProjectsSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProjectsSessionsCountDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSessionDataByFilterResponse parses an HTTP response from a GetSessionDataByFilterWithResponse call
func ParseGetSessionDataByFilterResponse(rsp *http.Response) (*GetSessionDataByFilterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSessionDataByFilterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionsData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFilterSetIdResponse parses an HTTP response from a CreateFilterSetIdWithResponse call
func ParseCreateFilterSetIdResponse(rsp *http.Response) (*CreateFilterSetIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterSetIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFilterSetResponse parses an HTTP response from a GetUserFilterSetWithResponse call
func ParseGetUserFilterSetResponse(rsp *http.Response) (*GetUserFilterSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFilterSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserFilterSetDto
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get filter options
	// (POST /api/reporter/p/{token}/filter-options)
	GetFilterOptions(ctx echo.Context, token AnalyticsToken, params GetFilterOptionsParams) error
	// Get interval filter options
	// (POST /api/reporter/p/{token}/interval-filter-options)
	GetIntervalFilterOptions(ctx echo.Context, token AnalyticsToken, params GetIntervalFilterOptionsParams) error
	// Count project sessions
	// (GET /api/reporter/p/{token}/projects/sessions/count)
	CountAllProjectsSessions(ctx echo.Context, token AnalyticsToken) error
	// Get sessions by filter
	// (POST /api/reporter/p/{token}/sessions/filter)
	GetSessionDataByFilter(ctx echo.Context, token AnalyticsToken, params GetSessionDataByFilterParams) error
	// Get filterSetId by user filter set
	// (POST /api/reporter/p/{token}/user-filter-sets/filterSetId)
	CreateFilterSetId(ctx echo.Context, token AnalyticsToken) error
	// Get user filter set
	// (GET /api/reporter/p/{token}/user-filter-sets/{filterSetId})
	GetUserFilterSet(ctx echo.Context, token AnalyticsToken, filterSetId FilterSetId) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetFilterOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetFilterOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFilterOptionsParams
	// ------------- Required query parameter "filterKey" -------------

	err = runtime.BindQueryParameter("form", true, true, "filterKey", ctx.QueryParams(), &params.FilterKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterKey: %s", err))
	}

	// ------------- Required query parameter "analyticsSection" -------------

	err = runtime.BindQueryParameter("form", true, true, "analyticsSection", ctx.QueryParams(), &params.AnalyticsSection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter analyticsSection: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("language")]; found {
		var Language LanguageHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "language", runtime.ParamLocationHeader, valueList[0], &Language)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
		}

		params.Language = &Language
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFilterOptions(ctx, token, params)
	return err
}

// GetIntervalFilterOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetIntervalFilterOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIntervalFilterOptionsParams
	// ------------- Required query parameter "filterKey" -------------

	err = runtime.BindQueryParameter("form", true, true, "filterKey", ctx.QueryParams(), &params.FilterKey)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterKey: %s", err))
	}

	// ------------- Required query parameter "analyticsSection" -------------

	err = runtime.BindQueryParameter("form", true, true, "analyticsSection", ctx.QueryParams(), &params.AnalyticsSection)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter analyticsSection: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "language" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("language")]; found {
		var Language LanguageHeader
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for language, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "language", runtime.ParamLocationHeader, valueList[0], &Language)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
		}

		params.Language = &Language
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIntervalFilterOptions(ctx, token, params)
	return err
}

// CountAllProjectsSessions converts echo context to params.
func (w *ServerInterfaceWrapper) CountAllProjectsSessions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CountAllProjectsSessions(ctx, token)
	return err
}

// GetSessionDataByFilter converts echo context to params.
func (w *ServerInterfaceWrapper) GetSessionDataByFilter(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSessionDataByFilterParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "needToReturnSessionLabels" -------------

	err = runtime.BindQueryParameter("form", true, false, "needToReturnSessionLabels", ctx.QueryParams(), &params.NeedToReturnSessionLabels)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter needToReturnSessionLabels: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSessionDataByFilter(ctx, token, params)
	return err
}

// CreateFilterSetId converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFilterSetId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFilterSetId(ctx, token)
	return err
}

// GetUserFilterSet converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserFilterSet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "token" -------------
	var token AnalyticsToken

	err = runtime.BindStyledParameterWithLocation("simple", false, "token", runtime.ParamLocationPath, ctx.Param("token"), &token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// ------------- Path parameter "filterSetId" -------------
	var filterSetId FilterSetId

	err = runtime.BindStyledParameterWithLocation("simple", false, "filterSetId", runtime.ParamLocationPath, ctx.Param("filterSetId"), &filterSetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filterSetId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserFilterSet(ctx, token, filterSetId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/api/reporter/p/:token/filter-options", wrapper.GetFilterOptions)
	router.POST(baseURL+"/api/reporter/p/:token/interval-filter-options", wrapper.GetIntervalFilterOptions)
	router.GET(baseURL+"/api/reporter/p/:token/projects/sessions/count", wrapper.CountAllProjectsSessions)
	router.POST(baseURL+"/api/reporter/p/:token/sessions/filter", wrapper.GetSessionDataByFilter)
	router.POST(baseURL+"/api/reporter/p/:token/user-filter-sets/filterSetId", wrapper.CreateFilterSetId)
	router.GET(baseURL+"/api/reporter/p/:token/user-filter-sets/:filterSetId", wrapper.GetUserFilterSet)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"L4cnAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
